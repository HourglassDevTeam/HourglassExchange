use crate::{
    common::{
        friction::{Fees, InstrumentFees, OptionFees, PerpetualFees, SpotFees},
        instrument::kind::InstrumentKind,
        order::{states::open::Open, Order},
        trade::ClientTrade,
        Side,
    },
    error::ExchangeError,
    hourglass::clickhouse_api::datatype::clickhouse_trade_data::MarketTrade,
    Exchange,
};
use rayon::prelude::ParallelSliceMut;
use serde::{Deserialize, Serialize};
use std::{
    fmt::Debug,
    sync::atomic::{AtomicI64, Ordering},
};

/// 客户端针对一个 [`Instrument`] 的 [`OpenOrdersBook`]。模拟客户端订单簿。
#[derive(Clone, Eq, PartialEq, Debug, Default, Deserialize, Serialize)]
pub struct OpenOrdersBook
{
    /// 在当前的代码设计中，batch_id 的递增仅在成功匹配订单并生成交易事件时发生
    // pub batch_id: i64,
    pub bids: Vec<Order<Open>>,
    pub asks: Vec<Order<Open>>,
}

/// 计算 [`Order<Open>`] 对应的 [`Fees`]
pub fn calculate_fees(order: &Order<Open>, trade_quantity: f64, fees_percent: f64) -> InstrumentFees
{
    match order.instrument.kind {
        // 针对现货交易的费用计算
        | InstrumentKind::Spot => {
            let spot_fees = SpotFees { maker_fee: fees_percent * trade_quantity, // 制造流动性的费率计算
                                       taker_fee: fees_percent * trade_quantity  /* 消耗流动性的费率计算 */ };
            InstrumentFees::new(order.instrument.kind, Fees::Spot(spot_fees))
        }

        // 针对永续合约的费用计算
        | InstrumentKind::Perpetual => {
            let perpetual_fees = PerpetualFees { maker_fee: fees_percent * trade_quantity,   // 开仓费率计算
                                                 taker_fee: fees_percent * trade_quantity,   // 平仓费率计算
                                                 funding_fee: fees_percent * trade_quantity  /* 资金费率计算 */ };
            InstrumentFees::new(order.instrument.kind, Fees::Perpetual(perpetual_fees))
        }

        // 针对期权交易的费用计算
        | InstrumentKind::CryptoOption => {
            let option_fees = OptionFees { trade_fee: fees_percent * trade_quantity /* 交易费率计算 */ };
            InstrumentFees::new(order.instrument.kind, Fees::Option(option_fees))
        }

        // 处理未知的交易类型
        | _ => panic!("Unsupported instrument kind!"),
    }
}

/// 添加一个 [`Order<Open>`] 到买单或卖单中，取决于它的 [`Side`]。
impl OpenOrdersBook
{
    pub fn add_order_open(&mut self, new_open_order: Order<Open>)
    {
        match new_open_order.side {
            | Side::Buy => {
                // 添加 Order<Open> 到买单
                self.bids.push(new_open_order);
                self.bids.par_sort();
            }
            | Side::Sell => {
                // 添加 Order<Open> 到卖单
                self.asks.push(new_open_order);
                self.asks.par_sort();
            }
        }
    }

    // 检查传入的 [`MarketTrade`] 与当前客户 [`Order<Open>`] 匹配的是买单还是卖单
    pub fn determine_matching_side(&self, market_event: &MarketTrade) -> Option<Side>
    {
        match market_event.side.as_str() {
            | "buy" => {
                // 如果市场方向是买单，检查卖单的最佳报价
                if let Some(best_ask) = self.asks.last() {
                    if market_event.price >= best_ask.state.price {
                        return Some(Side::Sell);
                    }
                }
            }
            | "sell" => {
                // 如果市场方向是卖单，检查买单的最佳报价
                if let Some(best_bid) = self.bids.last() {
                    if market_event.price <= best_bid.state.price {
                        return Some(Side::Buy);
                    }
                }
            }
            | _ => {
                println!("Input MarketTrade is likely to have mistaken 'side' info.")
            }
        }
        None
    }

    pub fn match_bids(&mut self, market_trade: &MarketTrade, fees_percent: f64, counter: &AtomicI64) -> Vec<ClientTrade>
    {
        let latest_trade_ts = market_trade.timestamp;

        // Track remaining liquidity for matching
        let mut remaining_liquidity = market_trade.amount;

        // Collect trades generated by matching outstanding bid orders
        let mut trades = Vec::new();

        while let Some(mut best_bid) = self.bids.pop() {
            let bid_timestamp = best_bid.timestamp;

            // 如果传入的market_trade.timestamp比bid_timestamp小，则跳过该bid，但不报错
            if latest_trade_ts < bid_timestamp {
                self.bids.push(best_bid);
                continue;
            }

            // If the best bid price is below the market trade price or liquidity is exhausted, exit loop
            if best_bid.state.price < market_trade.price || remaining_liquidity <= 0.0 {
                self.bids.push(best_bid);
                break;
            }

            // Increment the atomic counter (this returns the old value)
            counter.fetch_add(1, std::sync::atomic::Ordering::SeqCst);

            // Get the remaining quantity of the order
            let remaining_quantity = best_bid.state.remaining_quantity();

            // Determine if it's a full or partial fill
            if remaining_quantity <= remaining_liquidity {
                // Full fill
                remaining_liquidity -= remaining_quantity;
                trades.push(self.generate_client_trade_event(latest_trade_ts, &best_bid, remaining_quantity, fees_percent, counter).unwrap());

                // If liquidity is exactly exhausted, exit loop
                if remaining_liquidity == 0.0 {
                    break;
                }
            }
            else {
                // Partial fill
                let trade_quantity = remaining_liquidity;
                best_bid.state.filled_quantity += trade_quantity;
                trades.push(self.generate_client_trade_event(latest_trade_ts, &best_bid, trade_quantity, fees_percent, counter).unwrap());
                self.bids.push(best_bid); // Put the partially filled order back into the queue
                break;
            }
        }

        trades
    }

    pub fn match_asks(&mut self, market_trade: &MarketTrade, fees_percent: f64, counter: &AtomicI64) -> Vec<ClientTrade>
    {
        let latest_trade_ts = market_trade.timestamp;

        // Track remaining liquidity for matching
        let mut remaining_liquidity = market_trade.amount;

        // Collect trades generated by matching outstanding sell orders
        let mut trades = Vec::new();

        while let Some(mut best_ask) = self.asks.pop() {
            let ask_timestamp = best_ask.timestamp;

            // 略过 timestamp 比传入的 market_trade.timestamp 小的情况
            if latest_trade_ts < ask_timestamp {
                self.asks.push(best_ask);
                continue;
            }

            // If the best ask price is higher than the market trade price or liquidity is exhausted, exit loop
            if best_ask.state.price > market_trade.price || remaining_liquidity <= 0.0 {
                self.asks.push(best_ask);
                break;
            }

            // Increment the atomic counter, but pass the counter reference to generate_client_trade_event
            counter.fetch_add(1, Ordering::SeqCst);

            // Get the remaining quantity of the order
            let remaining_quantity = best_ask.state.remaining_quantity();

            // Determine if it's a full or partial fill
            if remaining_quantity <= remaining_liquidity {
                // Fully fill
                remaining_liquidity -= remaining_quantity;
                trades.push(self.generate_client_trade_event(latest_trade_ts, &best_ask, remaining_quantity, fees_percent, counter).unwrap());

                // If liquidity is exactly exhausted, exit loop
                if remaining_liquidity == 0.0 {
                    break;
                }
            }
            else {
                // Partial fill
                let trade_quantity = remaining_liquidity;
                best_ask.state.filled_quantity += trade_quantity;
                trades.push(self.generate_client_trade_event(latest_trade_ts, &best_ask, trade_quantity, fees_percent, counter).unwrap());
                self.asks.push(best_ask); // Put the partially filled order back into the queue
                break;
            }
        }

        trades
    }

    pub fn generate_client_trade_event(&self, timestamp: i64, order: &Order<Open>, trade_quantity: f64, fees_percent: f64, counter: &AtomicI64) -> Result<ClientTrade, ExchangeError>
    {
        let fee = trade_quantity * order.state.price * fees_percent;

        // Fetch the current value from the AtomicI64
        let trade_id = counter.load(Ordering::SeqCst); // Get the current value as an `i64`

        Ok(ClientTrade { exchange: Exchange::Hourglass,
                         timestamp,
                         trade_id: trade_id.into(), // Use the fetched trade ID
                         order_id: Some(order.state.id.clone()),
                         cid: order.cid.clone(),
                         instrument: order.instrument.clone(),
                         side: order.side,
                         price: order.state.price,
                         size: trade_quantity,
                         fees: fee })
    }

    /// 计算所有未成交买单和卖单的总数。
    pub fn num_orders(&self) -> usize
    {
        self.bids.len() + self.asks.len()
    }
}
